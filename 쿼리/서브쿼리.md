# 서브쿼리

```jsx
SELECT i. id, i. name, AVG(star) AS avg_star
FROM item AS i LEFT OUTER JOIN review AS r
ON r.item_id = i. id
GROUP BY i.id, i. name
HAVING avg_star < (SELECT AVG(star) FROM review)
ORDER BY avg_star DESC;
```

star의 평균을 구해 HAVING에 넣고 싶다면 직접 쿼리를 하나 더 열어서 값을 구해 직접 적어줘도 괜찮지만

위 코드처럼 쿼리 하나를 통째로 괄호안에 넣어서 사용할 수 있다.

그리고 이를 ‘**서브쿼리**’라고 한다.

```jsx
SELECT
	id,name,price, (SELECT AVG(price) FROM item) AS avg_price
FROM yunsu_main.item;
```

이런식으로 SELECT절에도 사용이 가능하다.

### WHERE 절에서 서브쿼리

```jsx
SELECT
	id,name,price, (SELECT AVG(price) FROM item) AS avg_price
FROM yunsu_main.item
WHERE price > (SELECT AVG(price) FROM item);
```

이런식으로 작성 가능하다.

```jsx
SELECT * FROM item
WHERE id IN
(
SELECT item_id
FROM review
GROUP BY item_id HAVING COUNT(*) >= 3
)
;
```

이런식으로도 사용이 가능하다

- any와 all
  이전 영상에서는 **하나의 column에 여러 개의 row들이 있는 결과**를 리턴하는 서브쿼리를 배웠습니다. 그리고 그런 서브쿼리 앞에 아래 그림처럼
  [](https://bakey-api.codeit.kr/files/3236/j0RPfM?name=r.png)
  **`IN`**을 붙여서 유용하게 사용했는데요. `IN` 말고도 이런 서브쿼리와 함께 유용하게 사용되는 다른 키워드들도 있습니다.
  바로 **`ANY`**와 **`ALL`**이라는 것인데요. 하나씩 배워볼게요.
  # **1. ANY의 의미**
  아래 그림을 잠깐 보겠습니다.
  [](https://bakey-api.codeit.kr/files/3236/rmlbDG?name=a.png)
  지금 **`codeit_theater`**라는 테이블에는
  - `id`(Primary Key)
  - `name`(영화 이름)
  - `category`(영화 장르)
  - `month`(개봉 월)
  - `view_count`(총 관객 수)
  컬럼이 있습니다.
  이 중에서 `category`의 값이 'Action'인 영화(액션 영화)들의 `view_count` 컬럼을 볼까요?
  [](https://bakey-api.codeit.kr/files/3236/8RPVUG?name=b.png)
  각 액션 영화의 관객 수가 잘 보입니다. 이전 영상에서 봤던 것처럼, **하나의 column에 여러 개의 row들이 있는 결과**죠? 이 `SELECT` 문을 서브쿼리로 사용해보겠습니다. 아래 그림의 노란색 부분이 이 SQL 문을 서브쿼리로 사용한 곳입니다.
  [](https://bakey-api.codeit.kr/files/3236/C4miqZ?name=c.png)
  그런데 지금 `WHERE` 절을 자세히 보면 서브쿼리 앞에 **`ANY`**라는 키워드가 붙어있습니다.
  간단하게 나타내보자면,
  ```sql

  WHERE view_count > ANY(서브쿼리)

  ```
  이런 식으로 조건이 설정되어 있는데요. 여기서 `ANY`는 무슨 뜻일까요?
  이 조건은 `view_count` 컬럼의 값이, 방금 전에 봤던 이 결과(서브쿼리가 리턴한 결과)
  [](https://bakey-api.codeit.kr/files/3236/5e43MA?name=d.png)
  에 있는 값(120000, 2300000, 7000000, 8500000) 중 **단 하나의(`ANY`)** 값보다도 크다면 `TRUE`를 리턴합니다.
  이 말은 곧, 4개의 값 중에서도 최소값인 120000보다**만** 큰 값이라면 조건을 만족하게 된다는 뜻이죠.
  [](https://bakey-api.codeit.kr/files/3236/3stFHS?name=e.png)
  이 서브쿼리가 사용된 전체 SQL 문의 실행 결과를 다시 보면, `view_count`가 120000보다 큰 영화들이, 그 중에서도 액션 영화를 제외하고(`AND category != 'Action'`) 조회되었습니다.
  **`ANY`**는 우리말로 '~중 하나라도'라는 뜻을 가지는 영어 단어입니다. `ANY`가 `WHERE` 절에서 사용될 때는, 서브쿼리의 결과에 있는 각 row의 값들 중 **하나라도 조건을 만족하는 경우가 있으면 `TRUE`를 리턴한다**는 뜻입니다. `ANY`와 같은 기능을 하는 **`SOME`**도 있는데요. 아래 그림처럼 `ANY` 대신 `SOME`을 사용해도
  [](https://bakey-api.codeit.kr/files/3236/viaD4a?name=f.png)
  `ANY` 때와 같은 결과를 출력하는 걸 알 수 있습니다. **`SOME`**은 '어떤 하나의~' 라는 뜻을 가진 영어 단어죠? `SOME`도 **서브쿼리의 결과에 있는 각 row의 값들 중 하나라도 조건을 만족**하면 `TRUE`를 리턴합니다. `ANY`와 `SOME`은 같은 기능을 하니까 원하는 것을 골라서 사용하시면 됩니다.
  # **2. ALL의 의미**
  이번에는 `ALL`이라는 키워드의 의미를 배워보겠습니다. 방금 전 봤던 SQL 문에서 `SOME` 부분만 `ALL`로 바꾸고 실행해보겠습니다.
  [](https://bakey-api.codeit.kr/files/3236/oJtmen?name=g.png)
  이번엔 다른 결과가 출력됐는데요. `ALL`은 '모든~' 이라는 뜻을 갖고 있죠? 그래서 `ALL`은 모든 경우에 대해서 해당 조건이 성립해야 `TRUE`를 리턴합니다. 서브쿼리의 실행 결과를 다시 보겠습니다.
  [](https://bakey-api.codeit.kr/files/3236/8QfXcG?name=h.png)
  `ALL`이 쓰였다면 **`view_count` 컬럼의 값이 여기 이 4가지 모든 값보다 커야 `TRUE`가 된다**는 뜻이죠.
  이 말은 곧, 여기서 최댓값인 8500000보다 커야 `TRUE`가 된다는 뜻인데요.
  [](https://bakey-api.codeit.kr/files/3236/qhi0Df?name=i.png)
  결과를 다시 자세히 보면 `view_count`가 8500000보다 많은 10000000인 ‘여름 왕국’만 결과에 있습니다. `ALL`이 어떤 기능을 하는지 아시겠죠?
  자, 이번 노트에서는 **하나의 column에 여러 row가 있는 결과를 리턴하는 서브쿼리**에 붙일 수 있는 **`ANY(SOME)`**와 **`ALL`**을 배웠습니다. 이 세 가지 단어의 의미를 잘 기억해두시고 필요할 때 유용하게 사용해보세요.

### FROM절에 서브쿼리

```jsx
SELECT AVG(review_count)
FROM
		(SELECT
		SUBSTRING (address, 1, 2) AS region,
		COUNT (*) AS review_count
		FROM review AS r LEFT OUTER JOIN member AS m
		ON r. mem_id = m. id
		GROUP BY SUBSTRING (address, 1, 2)
		HAVING region IS NOT NULL
		AND region != '안드') ;
```

서브쿼리를 하나의 테이블로 사용을 하는 것이다.

여기서 주의해야 할 점은 꼭 alias를 붙여줘야 한다는 점!

즉 위의 코드는 틀렸다.

고쳐보면

```jsx
SELECT AVG(review_count)
FROM
		(SELECT
		SUBSTRING (address, 1, 2) AS region,
		COUNT (*) AS review_count
		FROM review AS r LEFT OUTER JOIN member AS m
		ON r. mem_id = m. id
		GROUP BY SUBSTRING (address, 1, 2)
		HAVING region IS NOT NULL
		AND region != '안드') AS sub;
```

위 코드는 평균을 구했지만 최소,최대 등 여러가지를 구할 수 있다.

![스크린샷 2024-06-09 오후 4.46.58.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/97725b2e-027c-4697-871f-60f9a007ed7d/5199f728-925d-4206-97cc-db6ae1a72b02/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-06-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.46.58.png)

그리고 이런 서브쿼리를 ‘derived table’ 이라고 한다.

이는 그 sql문 안에서만 유용한 하나의 테이블이라고 생각하면 된다.

- 서브쿼리의 종류 정리

  이때까지 다양한 서브쿼리에 대해서 배워봤는데요.

  서브쿼리는 그것이 리턴하는 결과의 형태에 따라 여러 종류로 나눌 수 있습니다. 이때 다양한 종류가 있지만 실무적으로 유용한 3가지 종류를 정리하면 다음과 같습니다. 모두 우리가 배운 내용들입니다. 하나씩 설명할게요.

  # **1. 단일값을 리턴하는 서브쿼리**

  예)

  [](https://bakey-api.codeit.kr/files/3241/nRAqRA?name=a.png)

  하나의 값, 즉, 단일값을 리턴하는 서브쿼리입니다. 단일값은 수학, 물리 분야에서 **스칼라(scalar)**라고도 하는데요. 그래서 이런 서브쿼리를 **스칼라 서브쿼리**라고도 합니다. 이런 스칼라 서브쿼리는 `SELECT` 절에서 **하나의 컬럼**처럼, `WHERE` 절에서 **`=`, `>` 등의 조건 표현식과 비교하는 값으로** 쓸 수 있겠죠?

  # **2. 하나의 column에 여러 row들이 있는 형태의 결과를 리턴하는 서브쿼리**

  예)

  [](https://bakey-api.codeit.kr/files/3241/D2WHjD?name=b.png)

  하나의 column에, 여러 row가 있는 형태의 결과를 리턴하는 서브쿼리입니다. 이런 서브쿼리는 **`IN`, `ANY(SOME)`, `ALL`** 등의 키워드와 함께 쓸 수 있다고 했던 거, 기억나시죠?

  # **3. 하나의 테이블 형태의 결과(여러 column, 여러 row)를 리턴하는 서브쿼리**

  예)

  [](https://bakey-api.codeit.kr/files/3241/9WWkBc?name=c.png)

  테이블 형태의 값을 리턴하는 서브쿼리입니다. 이런 서브쿼리로 일시적으로 탄생한 테이블을 **derived table**이라고 한다고 했죠?(Oracle에서는 inline view라고도 합니다) 이런 서브쿼리로 생겨난 derived table은 마치 원래 있던 테이블인 것처럼 사용하면 됩니다. 대신, **derived table에는 alias를 붙여줘야 한다는 규칙이 있습니다.**

  자, 서브쿼리를 그 리턴 결과의 종류에 따라 나눠보았는데요. 서브쿼리가 리턴하는 결과의 형태를 잘 예측해야, 에러없이 서브쿼리를 활용할 수 있습니다. 그 정도 수준이 되려면 다양한 상황에서 서브쿼리를 쓰는 연습을 해봐야겠죠? 그리고 각 종류의 서브쿼리와 어떤 키워드들을 함께 쓸 수 있는지도 잘 기억하고 있는 게 좋습니다.

- EXISTS, NOT EXISTS 와 상관 서브쿼리
  이전 노트에서는 서브쿼리가 어떤 형식(column, row 수 기준)의 결과를 리턴하는지에 따라 그 종류를 나눠봤습니다.
  그런데 서브쿼리를 그 리턴 결과가 아닌 다른 측면에서도 분류해볼 수 있는데요.
  서브쿼리를 다른 방식으로 분류하는 방법은, 서브쿼리를
  - **비상관 서브쿼리**와
  - **상관 서브쿼리**로
  분류하는 것입니다. 이 내용은 좀 어려우니까 집중해서 읽어보세요.
  비상관 서브쿼리가 뭘까요? 잠깐 이전 영상에서 배운 SQL 문을 보고 설명해드릴게요.
  [](https://bakey-api.codeit.kr/files/3239/8av1U2?name=a.png)
  위 그림을 보시면 `WHERE` 절에서 서브쿼리가 사용되고 있는데요. 이 서브쿼리는 지금 **그 자체만으로도 실행이 가능한 서브쿼리**입니다. 따라서 이 서브쿼리만 빼서 아래 그림처럼 별도로 실행을 해봐도
  [](https://bakey-api.codeit.kr/files/3239/h3kdwu?name=b.png)
  잘 실행됩니다. 이것은 **이 서브쿼리가 그것을 둘러싼 outer query와 별개로, 독립적으로 실행되기 때문에** 그런 겁니다. 이렇게 outer query와 상관 관계가 없는 서브쿼리를 **비상관 서브쿼리**라고 합니다. **이때까지 우리가 배운 서브쿼리들이 모두 비상관 서브쿼리에 해당합니다.**
  그렇다면 상관 서브쿼리는 무엇일까요? 상관 서브쿼리는 우리가 지금 새롭게 배워야할 종류의 서브쿼리입니다. **상관 서브쿼리란 outer query와 상관 관계가 있는 서브쿼리를 말하는데요.** 아래 예시와 함께 설명할게요.
  [](<https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3239&directory=3m9g4mcxi-c(rev).png&name=3m9g4mcxi-c%28rev%29.png>)
  지금 이 그림을 보면 `WHERE` 절에 서브쿼리가 하나 쓰였습니다. 그리고 그 앞에 `EXISTS`라는 처음 보는 단어가 있는데요. `EXISTS`의 의미는 곧 바로 설명할게요. 일단 지금 서브쿼리의 뒷 부분을 보면 **`item`**이라는 테이블 이름이 있다는 것을 알 수 있습니다.
  그런데 여기서 **신기한 사실은 `item` 테이블의 이름이 서브쿼리의 `FROM` 절에 있는 게 아니라 outer query에 있다는 점인데요. 주황색 강조 처리된 두 개의 `item`이라는 테이블 이름을 보세요.**
  지금 서브쿼리가 필요로 하는 `item` 테이블이 outer query에 적혀있기 때문에 이 서브쿼리는 방금 전 '비상관 서브쿼리' 때와는 달리 단독으로 실행되지 못합니다. 잠깐 이 서브쿼리만 별도로 빼서 실행해보면,
  [](https://bakey-api.codeit.kr/files/3239/FRk7Vi?name=d.png)
  **방금 전의 비상관 서브쿼리와는 달리 실행에 실패합니다.** `item`이라는 테이블 이름이 지금 `FROM` 절에 없기 때문에 당연한 겁니다.
  이렇게 **서브쿼리가 outer query에 적힌 테이블 이름 등과 상관 관계를 갖고 있어서 그 단독으로는 실행되지 못하는 서브쿼리를 상관 서브쿼리라고 합니다.**
  그렇다면 지금
  [](<https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3239&directory=ze4ymzvct-e(rev).png&name=ze4ymzvct-e%28rev%29.png>)
  이 SQL 문 전체는 무슨 뜻일까요? 하나씩 해석해볼게요.
  먼저 SQL 문의 최종 조회 결과를 하나의 바구니라 생각하고 시작해보겠습니다.
  1. 일단 `item` 테이블의 첫 번째 row를 생각합시다.
  2. 그 row의 `id`(**`item.id`**) 값과 같은 값을 `item_id`(**`review.item_id`**) 컬럼에 가진 `review` 테이블의 row(가/들이) 있는지 조회합니다.
  3. 만약에 존재하면(`EXISTS`의 의미가 바로 이것입니다!, exist는 우리말로 '존재하다'라는 뜻입니다)
  4. `WHERE` 절은 TRUE가 되고, (1)에서 생각했던 `item` 테이블의 row는 최종 조회 결과 바구니에 담깁니다.
  이제 `item` 테이블의 두 번째 row에 대해서 (2) ~ (4)의 과정을 반복합니다.
  → 세 번째 row에 대해서 (2) ~ (4)의 과정을 반복합니다.
  → `item` 테이블의 마지막 row까지 (2) ~ (4)의 과정을 반복합니다.
  이렇게 되면 **`item` 테이블 중에서 그 `id` 컬럼 값이 `review` 테이블의 `item_id` 컬럼에 존재하는 row들만 추려지겠죠?** 이 말을 조금 바꿔서 말하면 **상품들 중에서 리뷰가 달린 상품들만 조회**한 것입니다. 상관 서브쿼리가 뭔지 조금 감이 오시나요?
  이것과 정 반대로 아직 리뷰가 달리지 않은 상품들만 조회하는 방법도 있습니다. 아래 그림과 같이 `EXISTS` 대신 **`NOT EXISTS`**를 사용하면 됩니다.
  [](<https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3239&directory=eexl8qmct-f(rev).png&name=eexl8qmct-f%28rev%29.png>)
  `NOT EXISTS`는 `EXISTS`와 정반대 의미로, 위에서 설명한 단계들에서 ‘(3)번 만약에 존재한다면’을 ‘**(3)번 만약에 존재하지 않는다면**’으로 바꾸고 생각하시면 됩니다. `NOT EXISTS`를 사용하니 리뷰가 달리지 않은 상품들만 잘 조회되었습니다.
  상관 서브쿼리가 뭔지, 상관 서브쿼리에서 사용되는 `EXISTS`, `NOT EXISTS`의 의미가 뭔지 이해되시나요?
  `EXIST`, `NOT EXISTS`는 상관 서브쿼리와 함께 자주 사용되는 키워드이기 때문에 그 의미를 잘 기억해두시는 게 좋습니다.
  하지만 **상관 서브쿼리라고 해서 꼭 `EXISTS`, `NOT EXISTS` 같은 키워드를 써야만 하는 건 아닙니다.** 잠깐 아래 그림을 보세요. 상관 서브쿼리로 이런 것도 할 수 있습니다.
  지금 저는 `member` 테이블을 조회하면서, 같은 해에 태어난 회원들 중 **가장 작은 키**를 가진 회원의 키 정보를 담은 컬럼을 오른쪽 끝에 추가해서 보려고 하는데요. 방금 전에 배운 상관 서브쿼리의 해석 방법대로 아래 SQL 문을 해석해보세요.
  [](<https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3239&directory=87cq99t64-g(rev).png&name=87cq99t64-g%28rev%29.png>)
  지금 보면 `member` 테이블 하나를 갖고 마치 이전에 배운 [SELF JOIN 같은 작업](https://www.codeit.kr/topics/data-analysis-using-sql/lessons/3230)을 처리하고 있다는 걸 알 수 있습니다.
  혹시 해석이 바로 안 되시는 분들을 위해 이미지에 있는 번호대로 하나씩 설명해드릴게요.
  **1번**: 일단 `birthday` 컬럼과 `height` 컬럼에 둘다 값이 있는 회원들만 대상으로 해야하기 때문에 이런 조건을 걸었습니다.
  그 다음 `member` 테이블의 첫 번째 row를 생각합시다.
  **2번** : 그 row에 대해서 같은 **`YEAR(birthday)` ('생일연도')** 값을 가진 row(를/들을) 찾습니다.
  **3번** : 그 다음 해당 row(의/들의) `height` 컬럼의 최솟값을 구합니다.
  `member` 테이블의 두 번째 row를 생각하고, 2~3번을 수행합니다.
  `member` 테이블의 세 번째 row를 생각하고 ,2~3번을 수행합니다.
  …
  이런 식으로 구하다 보면 특정 회원과 같은 해에 태어난 사람들 중 가장 작은 키를 가진 사람의 키를 마지막 컬럼에서 볼 수 있습니다.
  위 결과를 보면 같은 해에 태어난 회원들은 `min_height_in_the_year`라는 컬럼에서 모두 같은 값을 갖고 있는 것을 확인할 수 있습니다.
  자, 상관 서브쿼리는 처음 배울 때는 조금 어려울 수도 있는 개념입니다. 위 내용을 이해될 때까지 반복해서 읽어보세요.
  참고로 비상관 서브쿼리는 영어로 **Non-correlated Subquery**, 상관 서브쿼리는 영어로 **Correlated Subquery**라고 합니다.

### 뷰

sql이 서브쿼리를 중첩하고 하다보면 너무 길어지고 하는데 이는 뷰라는것을 사용해 해결할 수 있다.

![스크린샷 2024-06-09 오후 6.23.57.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/97725b2e-027c-4697-871f-60f9a007ed7d/4f88958b-4734-42f0-8790-16bf7c6a5f83/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-06-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.23.57.png)

위 사진을 예시로 보면 1번쿼리와 4번이 같은데 두번 사용하다보니 너무 길어지고 복잡해졌다.

뷰는

조인 등의 작업을 해서 만든 ‘결과 테이블’이 가상으로 저장된 형태

```jsx
CREATE VIEW three_tables_joined AS
SELECT ....
```

이렇게 하면 SELECT뒤에 오는 sql문이 생성하는 결과 테이블을 저장을 하게 된다.

이제 일반 테이블처럼 가져다 사용하면 된다.

- 뷰에 관해 알아야할 사실
  이전 영상에서 **뷰(View)**를 ‘**가상 테이블**’이라고도 한다고 말했습니다. 그럼 뷰와 그냥 테이블은 무슨 차이가 있는 걸까요?
  가장 큰 차이는 뷰는 테이블과 달리 데이터가 물리적으로 컴퓨터에 저장되어 있는 건 아니라는 점입니다.
  테이블은 우리가 표 형식으로 보는 데이터들이 실제로 컴퓨터에 저장되어 있습니다.
  그런데 뷰는 표 형식으로 내용을 본다는 점에서는 테이블과 같지만, 테이블처럼 그 내용이 실제로 컴퓨터에 일일이 저장되어 있는 건 아니라는 점이 다릅니다. 그 대신 뷰는, 우리가 뷰를 사용할 때, DBMS가 그 뷰를 생성하는 SQL 문을 재실행하는 방식으로 가상의 테이블을 만들어주는 겁니다. 잠깐 아래 그림으로 설명해보자면,
  [](https://bakey-api.codeit.kr/files/3249/SH0Ecl?name=a.png)
  우리가 `three_tables_joined` 라는 뷰를 사용할 때마다 `AS` 다음에 있는 빨간 박스 안의 `SELECT` 문이 재실행된다는 뜻입니다.
  즉, 뷰라는 건, 테이블처럼 컴퓨터에서 데이터 크기만큼의 물리적인 용량을 차지하고 있는 것은 아니라는 뜻입니다. (요즘에는 자주 사용하는 뷰인 경우, 테이블처럼 데이터가 물리적으로 저장되도록 하는 기능도 있는데요. 중요한 내용은 아니니까 넘어갈게요)
  뷰는 데이터베이스에 저장된 데이터를 분석해야할 때 매우 유용한 개념이자 기능입니다. 뷰의 장점들을 하나씩 살펴보겠습니다.
  **첫 번째, 뷰는 사용자에게 높은 편의성을 제공해줍니다.**
  이전 영상에서 본 것처럼 여러 테이블을 조인하는 SQL문을 매번 필요할 때마다 사용하는 것은 정말 번거로운 일입니다. 하지만 이런 복잡한 SQL문을 뷰로 한번 저장해두면 계속 재활용할 수 있어서 정말 편리하죠. 이건 이미 실감해봤으니까 바로 넘어갈게요.
  **두 번째, 각 직무별 데이터 수요에 알맞은, 다양한 구조의 데이터 분석 기반을 구축해둘 수 있습니다.**
  같은 테이블들이 존재하는 상황에서도, 직무에 따라, 상황에 따라, 필요로 하는 데이터의 종류와 그 구조가 사람마다 다를 수 있는데요. 뷰를 사용하면 각자에게 적합한 구조로 데이터들을 준비해둘 수 있기 때문에 회사 입장에서도 기존의 테이블 구조를 건드리지 않고, 풍부한 데이터 분석 기반을 준비할 수 있게 됩니다.
  **세 번째, 뷰는 데이터 보안을 제공합니다.**
  이 부분이 상당히 중요한데요. 예를 들어, 회사에서 직원들에 관한 정보를 담고 있는 **`employee`**라는 테이블이 있고 이 테이블에는 굉장히 민감한 정보가 담긴 컬럼들이 있다고 가정합시다. 예를 들어, **주민등록번호**나 **주소**, **연봉** 등과 같은 정보 말이죠. 그런데 회사 내의 데이터 분석가가 어떤 분석을 하기 위해 이 **`employee`** 테이블이 필요할 수도 있습니다. 하지만 아무리 데이터 분석을 해야한다고 해도 중요한 정보를 분석가가 마음대로 볼 수 있게 하는 것은 옳지 않습니다. 이때 분석가에게 민감 정보가 담긴 컬럼을 제외하고 보여줄 수 있는 방법도 바로 뷰입니다.
  한 예로 `employee` 테이블에 `id`, `name`, `age`, `department`, `registration_number`(주민등록번호), `annual_salary`(연봉) 컬럼이 있다고 가정했을 때, 이 테이블을 바로 데이터 분석가가 사용할 수 있도록 하면 안 됩니다.
  이런 상황에서는
  ```sql

  CREATE VIEW emp_view AS
      SELECT id,
             name,
             age,
             department
      FROM employee;

  ```
  같은 SQL 문을 실행해서 테이블과 비슷한 이름의 뷰를 만드는 게 좋습니다.
  특정 column들 뿐만 아니라 특정 row들을 공개하지 않는 것도 가능합니다. 예를 들어 **`department`**의 값이 '**secret**'인 직원들의 정보를 공개하지 않아야 한다고 가정해본다면, 이런 뷰를 만들면 되겠죠?
  ```sql

  CREATE VIEW emp_view2 AS
      SELECT id,
             name,
             age,
             department
      FROM employee
      WHERE department != 'secret';

  ```
  이렇게 `WHERE` 절로 조건을 붙여서, 특정 row들만 보여주는 뷰를 만드는 것도 가능합니다.
  이런 SQL 문을 사용해서, 공개 가능한 정보만 있는 뷰를 만들고 난 후에는, 데이터 분석가가 **`employee`** 테이블에 직접적인 접근을 하지 못하도록 막고(DBMS에서 '사용자별 권한 관리' 기능을 통해 할 수 있습니다), **`emp_view` 뷰에만 접근할 수 있도록 하면 됩니다.**
  나중에 여러분이 회사에서 데이터 분석을 해야할 때는 테이블 자체보다는 이러한 뷰를 제공받을 가능성이 더 높습니다. 실제 서비스에서 사용되는 테이블에는 보통, 아무나 접근해서 작업을 할 수 없도록 보안 정책이 철저하게 구축되어 있을 겁니다. 하지만 그렇다고 그런 권한을 가진 사람이 데이터 분석 직무를 맡게 되는 것도 아니죠. 바로 이런 현실적인 문제를 해결하는 수단이 뷰가 되는 겁니다. 뷰가 어떻게 쓰이는지 감이 오시죠?
  혹시 나중에 실무에서 '테이블을 직접 다루는 게 아니구나'라고 실망하지 마세요. 만약 제공받은 뷰로 부족함을 느낀다면 테이블에 직접 접근할 수 있는 개발자 분 등에게 요청해서 원하는 구조의 뷰를 제공받으면 됩니다.
