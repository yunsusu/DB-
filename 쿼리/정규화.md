# 정규화 (Normalization)

아무리 주의깊게 해도 데이터베이스가 복잡해질수록 실수로 모델링을 잘못하거나 잘했는지 판단하기 힘들어진다.

이를 해결하기 위한게 정규화다

- 데이터베이스의 테이블이 잘 만들어졌는지 평가하고, 잘 만들지 못한 테이블을 고쳐나가는 과정
- 테이블을 정규형(normal form)이라고 불리는 형태에 부합하게 만들어나감

### 정규형(Normal Form)

- 1NF, 2NF, 3NF…
- 순서에 따라 규칙이 누적된다.

![스크린샷 2024-07-28 오후 2.24.44.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/97725b2e-027c-4697-871f-60f9a007ed7d/71871eec-fe1e-485a-93f6-e1106473a4b8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.24.44.png)

이런 형식으로 진행된다

정규형은 이 세가지 말고도 많다.

대부분의 경우 3정규형까지만 잘 부합해도 잘 정규화된 데이터베이스라고 한다.

잘 정규화를 시키면

- 데이터베이스에서 삽입, 업데이트, 삭제 이상을 없앨 수 있다.
- 새로운 종류의 데이터를 추가할 때 테이블 구조 수정을 많이 하지 않아도 된다
- 데이터베이스 구조를 단순화해서 사용자가 더 쉽게 이해할 수 있다

정규화는 데이터 모델을 만들고, 데이터베이스에 구현하기 전에 적용하면 좋다

# 1NF

- 테이블 안 모든 로우의 모든 컬럼 값들은 나눌 수 없는 단일 값이어야 한다.

![스크린샷 2024-07-28 오후 2.39.00.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/97725b2e-027c-4697-871f-60f9a007ed7d/79b75fe8-6a1d-4fbb-bc08-de0e0f62b354/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.39.00.png)

예시로 이런 전화번호를 볼 수 있다.

- 1NF 상세
  # **1NF: 나눌 수 없는 단일 값**
  테이블이 1NF에 부합하기 위해서는 안에 있는 모든 값이 나눌 수 없는 단일 값이어야 한다.
  영상에서 본 것처럼 아래 테이블은 1NF를 지키고 있지 않는다. 한 phone_numbers 컬럼이 여러 개의 전화 번호들을 저장하고 있기 때문.
  [](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4448&directory=Screen_Shot_2021-02-19_at_5.25.11_PM.png&name=Screen_Shot_2021-02-19_at_5.25.11_PM.png)
  이 경우에는 이렇게 phone_numbers 컬럼을 분리해서 새로운 테이블로 만들어야 한다.
  [](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4448&directory=Screen_Shot_2021-02-19_at_5.25.37_PM.png&name=Screen_Shot_2021-02-19_at_5.25.37_PM.png)
  아래와 같이 하나의 컬럼을 여러 개로 나누는 것보다 훨씬 더 깔끔한 방법
  [](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4448&directory=Screen_Shot_2021-02-19_at_5.25.55_PM.png&name=Screen_Shot_2021-02-19_at_5.25.55_PM.png)
  지난 챕터에서는 이렇게 같은 내용을 저장하는 컬럼이 여러 개가 있을 때는:
  1. NULL이 많이 생길 수 있게 된다
  2. 컬럼을 몇 개를 만들어야 되는지 애매해진다
  3. 조회가 비효율적이게 된다
  이 세 가지 문제점이 생긴다.
  # **1NF: 확대 해석**
  사실 1NF를 단순하게 의미 그대로 해석한다면, 컬럼을 여러 개로 나누는 것도 테이블이 1NF를 지키게 바꾸는 게 맞긴한데
  1NF를 확대해서 해석 한다면, 컬럼을 늘리는 방법은 1NF를 지킨다고 볼 수 없다.
  어떤 데이터베이스 학자들은 "나눌 수 없는 단일 값"을 테이블 안에 있는 모든 값들이 **무조건 하나**의 값만 가져야 된다는 의미로 해석한다.
  1NF를 지키기 위해서 단순히 테이블의 컬럼을 늘리게 된다면 **구조적**으로 NULL이 많이 생기게 되는 문제가 발생하게 되는데, NULL은 아무 값도 없는, 즉 0개의 값을 저장하는 것이다. 0개는 단일 값, 즉 하나의 값에 해당하지 않기 때문에 컬럼을 늘리는 것과 같이 구조적으로 NULL이 많이 발생할 수 있는 테이블들이 1NF에 부합한다고 볼 수 없다고 주장한다.
  # **컬럼에 서로 같은 여러 값이 저장돼있을 때**
  1NF를 어떻게 해석하는지와 상관 없이 위 경우에서 단순히 **같은 데이터를 저장하는 컬럼을 늘려서** 1NF를 지키려고 하는 방법은 좋지 않은 모델링이다. 컬럼을 따로 테이블로 분리해야 한다.
  # **컬럼에 서로 다른 여러 값이 저장돼있을 때**
  1NF를 지키지 않는 경우는 **같은 종류의 값 여러 개**를 저장하고 있는 경우뿐만 아니라, **서로 다른 종류의 값 여러 개**를 저장하고 있는 경우도 있다.
  # **나눌 수 없는 단일 값 기준**
  그렇다면 **나눌 수 없는 단일 값**이라는 기준은?
  사실 길이가 2 이상인 모든 문자열은 더 작은 문자로 나눌 수 있고 (예: "cat" —> "c", "a", "t") 소수도 소수 부분과 (0.1234) 정수 부분 (5678)으로 나눌 수 있는데, 이걸 다 따로 저장할 수는 없다.
  이런 문제점들 때문에 "나눌 수 없는 단일 값"이라는 표현 자체가 **불완전**하다는 의견도 많이 있기는 하다.
  그 의미가 항상 명확하진 않을 수 있어도, 컬럼 값을 사용할 때 **온전히 그 단위 자체**로 사용하는지, 저장하는 값들을 **일부분만 사용할 수도 있는지**를 판단하고 그걸 바탕으로 모델링해야 한다.
  # **정리**
  핵심만 정리해보면 1NF를 지키지 않는 경우는 크게 두 가지가 있다.
  1. 한 컬럼에 **같은 종류의 값**을 여러 개 저장하고 있을 때
  - 이때는 해당 컬럼을 하나의 테이블로 분리해서 모델링.
  2. 한 컬럼에 **서로 다른 종류의 값**을 여러 개 저장하고 있을 때
  - 이때는 한 컬럼을 여러 개로 분리해서 모델링.

# 함수 종속성 (Functional Dependency)

2,3 정규형에 사용되는 개념

![스크린샷 2024-07-28 오후 2.56.35.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/97725b2e-027c-4697-871f-60f9a007ed7d/81ac96ae-0ef2-4c7f-bcb0-d518afaa507e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.56.35.png)

![스크린샷 2024-07-28 오후 2.59.13.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/97725b2e-027c-4697-871f-60f9a007ed7d/44733ac5-6c6a-496a-9224-40eb37db0f17/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.59.13.png)

그리고 한개 뿐만 아니라 아래처럼 두개에 대한 종속성을 나타낼 수 있다.

![스크린샷 2024-07-28 오후 3.01.27.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/97725b2e-027c-4697-871f-60f9a007ed7d/09fec96e-be80-4795-8cc6-0eb9cb1bb3c2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.01.27.png)

## 이행성

A를 종속하는 B를 종속하는 C

처럼 하나 이상의 attribute를 건너서 함수 종속성이 있는 경우 함수 종속성이 넘어갔다, 즉 이행됐다해서

C는 A에게 이행적 함수 종속성이 있다고 한다.

# Candidate Key

하나의 로우를 특정 지을 수 있는 attribute들의 최소 집합

![스크린샷 2024-07-28 오후 3.12.42.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/97725b2e-027c-4697-871f-60f9a007ed7d/f980aa06-c99d-4025-b851-0fce075166ea/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.12.42.png)

candidate key에 포함된 모든 attribute는 prime attribute라고 부른다.

# 2NF

- 1NF에 부합해야 한다 (테이블 안 모든 값이 나눌 수 없는 단일 값이어야 한다.)
- 테이블에 candidate key의 일부분에 대해서만 함수 종속성이 있는 non-prime attribute가 없어야 한다.

# 3NF

- 2NF에 부합해야 한다
- 테이블 안에 있는 모든 attribute들은 오직 primary key에 대해서만 함수 종속성이 있어야 한다.
  - 테이블의 모든 attribute는 직접적으로 테이블 Entity에 대한 내용이어야만 한다.

정리를 해보자면
**1NF** : 테이블이 1NF에 부합하기 위해서는 테이블 안에 있는 모든 값이 **나눌 수 없는 단일 값**
**2NF** : candidate key의 일부분에만 의존하는 non-prime attribute은 없어야 한다.
[](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4430&directory=Screen_Shot_2021-02-16_at_12.49.43_PM.png&name=Screen_Shot_2021-02-16_at_12.49.43_PM.png)
[](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4430&directory=Screen_Shot_2021-02-16_at_1.03.45_PM.png&name=Screen_Shot_2021-02-16_at_1.03.45_PM.png)
**3NF** : 테이블 안 모든 attribute은 primary key에 대해 직접적인 함수 종속성이 있어야한다.
