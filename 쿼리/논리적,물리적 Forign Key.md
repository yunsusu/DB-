# 논리적 Foreign Key, 물리적 Forign Key
  주문 테이블 - 배송 테이블,
  
  회원 테이블 - 댓글 테이블,
  
  부서 테이블 - 직원 테이블 등
  
  처럼
  많은 테이블들이 Foreign Key를 매개로 해서 관계를 맺고 있고, 여러 테이블들을 하나로 합치는 조인(Join)을 이 Foreign Key 기준으로 하는 것이 일반적이기 때문에, 현재 데이터베이스에 존재하는 Foreign Key들을 잘 파악하는 것이 중요하다.
  
  그런데 데이터베이스의 테이블을 살펴보다보면
  **어떤 테이블의 특정 컬럼이 Foreign Key로 설정되어야할 것 같은데**
  **Foreign Key로 설정되지 않은 경우**를 보게될 수도 있다.
  
  사실 어느정도 짐작하셨겠지만, 어떤 테이블의 한 컬럼이
  논리적으로 다른 테이블의 컬럼을 참조(reference)해야해서 개념상 Foreign Key에 해당하는 것과,
  실제로 해당 컬럼을 Foreign Key로 설정해서 두 테이블 간의 참조 무결성을 지킬 수 있게되는 것은 별개의 개념이다.
  
  그래서 보통 이 둘을 나누어서 개념상, 논리적으로 성립하는 Foreign Key를 **논리적(Logical) Foreign Key**라고 하고,
  DBMS 상에서 실제로 특정 컬럼을 Foreign Key로 설정해서 두 테이블 간의 참조 무결성을 보장할 수 있게 됐을 때, 그 컬럼을 **물리적(Physical) Foreign Key**라고 한다.
  
  데이터베이스에 들어갈 여러 테이블들을 설계하다보면 당연히 여러 논리적 Foreign Key들이 생길 수밖에 없다. 하지만 실제로는 논리적 Foreign Key라고 해서 꼭 그것을 물리적 Foreign Key로 설정하는 것은 아니다. 물리적 Foreign Key로 설정한다면 참조 무결성이 보장되니까 좋을텐데.. 설정하지 않는 이유들이 몇가지 있다.
  
  ## **1. 성능 문제**
  실제 서비스에 의해 사용되고 있는 데이터베이스의 테이블들은 단 1초 내에도 수많은 조회(SELECT), 추가(INSERT), 갱신(UPDATE), 삭제(DELETE) 작업이 일어나고 있을 수 있다. 이럴 때 SQL 문 하나하나가 얼마나 빨리 실행되는지가 사용자의 만족도에 큰 영향을 미치게 될 것이다.
  
  **물리적 Foreign Key가 있는 자식 테이블의 경우에는 INSERT, UPDATE 문 등이 실행될 때 약간의 속도 저하가 발생할 가능성이 있다.** 왜냐하면 INSERT, UPDATE 문이 실행될 때 혹시라도 참조 무결성을 깨뜨리는 변화가 발생하지는 않을지 추가적으로 검증해줘야 하기 때문이다. 즉, 물리적 Foreign Key를 설정하게 되면, 데이터의 참조 무결성을 보장해주는 대신, 성능 부분에서는 약간의 양보가 필요하게 되는 것이다.
  
  만약 데이터의 참조 무결성보다는 일단 당장 빠른 성능이 중요하다면 물리적 Foreign Key를 굳이 설정하지 않기도 한다. 그리고 이렇게 일단은 INSERT, UPDATE 문 등이 보다 더 빠르게 실행되도록 하고, 참조 무결성을 어기는 데이터들은 정기적으로 별도 확인 후에 삭제해주는 방식을 택하기도 한다.
  
  ## **2. 레거시(Legacy) 데이터의 참조 무결성이 이미 깨진 상태라면?**
  IT 세계에는 레거시(Legacy)라고 하는 용어가 있다. Legacy는 ‘유물, 유산’ 이런 뜻을 가지는 단어인데, IT 세계에서는 프로그램의 기존 코드, 기존 데이터 등을 나타낼 때 사용하는 말이다.
  
  데이터베이스 쪽 분야에서는 레거시 데이터라는 말을 흔히 쓰기도 한다. 어떤 회사에 개발자로 입사했을 때, 이미 그 회사에 쌓여있던 데이터라고 생각하시면 된다. 만약 이런 레거시 데이터들을 살펴봤는데 그 회사가 그동안 물리적 Foreign Key 없이 데이터를 쌓아와서 참조 무결성을 어기는 row들이 생겨버린 상황이라고 해보면.
  
  이런 경우에 어떤 선택을.. 일단 참조 무결성을 어기는 row들을 과감하게 지워버린 후에 물리적 Foreign Key를 설정하는 방법이 있을 것이다. 하지만 만약 참조 무결성을 어기는 row들의 수가 많고, 그것들도 소중한 데이터라서 함부로 삭제할 수 없는 상황이라면?
  
  물론 입사한 이후부터는 참조 무결성을 지키면서 데이터를 저장하도록 할 수는 있다. 하지만 아무리 그 뒤로 참조 무결성을 지킨다고 해도 이미 레거시 데이터 때문에 전체적인 차원에서의 참조 무결성은 깨져버린 상태가 된다.
  
  바로 이런 현실적인 이유 때문에 그냥 물리적 Foreign Key없이, 참조 무결성을 지키는 것을 포기하고 서비스를 운영하는 곳들도 생겨나게 되는 것이다. 참조 무결성이 깨지더라도 일단 소중한 데이터들을 삭제하지는 말자는 생각인 것이다.

  
  ##
  위에서 본 이유 등으로 인해 실무에서는 **논리적 Foreign Key를 굳이 물리적 Foreign Key로 설정하지 않는 경우도 많다.**
  하지만 분명한 것은 데이터의 **참조 무결성(Referential Integrity)**을 완벽하게 지켜야하는 서비스(은행, 학적 관리 서비스 등)에서는 논리적 Foreign Key를 반드시 물리적 Foreign Key로 설정해야한다. 100%의 정확성이 요구되는 서비스에서 참조 무결성이 깨져버린다면, 상상하고 싶지 않은 최악의 상황을 만나게 되기 때문이다.
